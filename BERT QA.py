# -*- coding: utf-8 -*-
"""hw7_bert.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H7x92ry-31npX4HpKA7ci4UXhBBzWAno

# **Homework 7 - Bert (Question Answering)**

If you have any questions, feel free to email us at ntu-ml-2021spring-ta@googlegroups.com



Slide:    [Link](https://docs.google.com/presentation/d/1aQoWogAQo_xVJvMQMrGaYiWzuyfO0QyLLAhiMwFyS2w)　Kaggle: [Link](https://www.kaggle.com/c/ml2021-spring-hw7)　Data: [Link](https://drive.google.com/uc?id=1znKmX08v9Fygp-dgwo7BKiLIf2qL1FH1)
"""

from google.colab import drive
drive.mount('/content/drive')

"""## Task description
- Chinese Extractive Question Answering
  - Input: Paragraph + Question
  - Output: Answer

- Objective: Learn how to fine tune a pretrained model on downstream task using transformers

- Todo
    - Fine tune a pretrained chinese BERT model
    - Change hyperparameters (e.g. doc_stride)
    - Apply linear learning rate decay
    - Try other pretrained models
    - Improve preprocessing
    - Improve postprocessing
- Training tips
    - Automatic mixed precision
    - Gradient accumulation
    - Ensemble

- Estimated training time (tesla t4 with automatic mixed precision enabled)
    - Simple: 8mins
    - Medium: 8mins
    - Strong: 25mins
    - Boss: 2hrs

For BERT這次作業，輸入表示為[CLS]問題[SEP]段落(一個window的量)[SEP] (在QA_Dataset中實作), 模型輸出預測答案的起始位置和結束位置。在訓練過程中，提供給模型問題、包含答案的段落，以及答案在段落中的真實起始和結束位置。model會學習調整自身的weight，使對於給定的問題和段落，真實答案的起始和結束位置的預測概率更高。
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/MyDrive
# %cd ./ML2021/homework7
!pwd

"""## Download Dataset"""

# Download link 1
#!gdown --id '1znKmX08v9Fygp-dgwo7BKiLIf2qL1FH1' --output hw7_data.zip

# Download Link 2 (if the above link fails)
# !gdown --id '1pOu3FdPdvzielUZyggeD7KDnVy9iW1uC' --output hw7_data.zip

#!unzip -o hw7_data.zip

# For this HW, K80 < P4 < T4 < P100 <= T4(fp16) < V100
#!nvidia-smi

"""## Install transformers

Documentation for the toolkit:　https://huggingface.co/transformers/
"""

!pip install transformers

"""## Import Packages"""

import json
import numpy as np
import random
import torch
from torch.utils.data import DataLoader, Dataset
from transformers import BertForQuestionAnswering, BertTokenizerFast
from transformers.optimization import get_linear_schedule_with_warmup
from torch.optim import AdamW

from tqdm.auto import tqdm

device = "cuda" if torch.cuda.is_available() else "cpu"

# Fix random seed for reproducibility
def same_seeds(seed):
	torch.manual_seed(seed)
	if torch.cuda.is_available():
		torch.cuda.manual_seed(seed)
		torch.cuda.manual_seed_all(seed)
	np.random.seed(seed)
	random.seed(seed)
	torch.backends.cudnn.benchmark = False
	torch.backends.cudnn.deterministic = True
same_seeds(0)

# Change "fp16_training" to True to support automatic mixed precision training (fp16)
#fp16減少float表示bit,減少記憶體和更快的運算，精度較低
fp16_training = True

if fp16_training:
    !pip install --upgrade accelerate
    from accelerate import Accelerator
    accelerator = Accelerator(mixed_precision="fp16") #自動處理在模型的不同部分使用不同精度，有些fp16有些fp32
    device = accelerator.device

# Documentation for the toolkit:  https://huggingface.co/docs/accelerate/

"""## Load Model and Tokenizer





"""

model = BertForQuestionAnswering.from_pretrained("bert-base-chinese").to(device)
tokenizer = BertTokenizerFast.from_pretrained("bert-base-chinese") #Tokenizer 作用是將輸入文本轉換為model可理解的tokenID，並處理預處理步驟，ex分詞、添加特殊token(CLS,SEP)等。

# You can safely ignore the warning message (it pops up because new prediction heads for QA are initialized randomly)

"""## Read Data

- Training set: 26935 QA pairs
- Dev set: 3523  QA pairs
- Test set: 3492  QA pairs

- {train/dev/test}_questions:
  - List of dicts with the following keys:
   - id (int)
   - paragraph_id (int)
   - question_text (string)
   - answer_text (string)
   - answer_start (int)
   - answer_end (int)
- {train/dev/test}_paragraphs:
  - List of strings
  - paragraph_ids in questions correspond to indexs in paragraphs
  - A paragraph may be used by several questions
"""

def read_data(file):
    with open(file, 'r', encoding="utf-8") as reader:
        data = json.load(reader)
    return data["questions"], data["paragraphs"]

train_questions, train_paragraphs = read_data("hw7_train.json")
dev_questions, dev_paragraphs = read_data("hw7_dev.json")
test_questions, test_paragraphs = read_data("hw7_test.json")

"""## Tokenize Data(分詞處理)

"""

# Tokenize questions and paragraphs separately
# 「add_special_tokens」 is set to False since special tokens will be added when tokenized questions and paragraphs are combined in datset __getitem__

train_questions_tokenized = tokenizer([train_question["question_text"] for train_question in train_questions], add_special_tokens=False)
dev_questions_tokenized = tokenizer([dev_question["question_text"] for dev_question in dev_questions], add_special_tokens=False)
test_questions_tokenized = tokenizer([test_question["question_text"] for test_question in test_questions], add_special_tokens=False)

train_paragraphs_tokenized = tokenizer(train_paragraphs, add_special_tokens=False)
dev_paragraphs_tokenized = tokenizer(dev_paragraphs, add_special_tokens=False)
test_paragraphs_tokenized = tokenizer(test_paragraphs, add_special_tokens=False)

# You can safely ignore the warning message as tokenized sequences will be futher processed in datset __getitem__ before passing to model

"""為了設定max_paragraph_len, doc_stride所寫"""

import matplotlib.pyplot as plt
paragraph_lengths = [len(x) for x in train_paragraphs_tokenized['input_ids']]

average_length = np.mean(paragraph_lengths)
median_length = np.median(paragraph_lengths)
max_length = np.max(paragraph_lengths)
min_length = np.min(paragraph_lengths)
percentile_90 = np.percentile(paragraph_lengths, 90)


print(f"Tokenized Paragraph Length Statistics:")
print(f"  Min Length: {min_length}")
print(f"  Max Length: {max_length}")
print(f"  Average Length: {average_length:.2f}")
print(f"  Median Length: {median_length:.2f}")
print(f"  90th Percentile Length: {percentile_90:.2f}")

plt.figure(figsize=(12, 6))
plt.hist(paragraph_lengths, bins=50, edgecolor='black', alpha=0.7)
plt.title('Distribution of Tokenized Paragraph Lengths')
plt.xlabel('Number of Tokens')
plt.ylabel('Number of Paragraphs')
plt.grid(axis='y', alpha=0.75)
plt.axvline(average_length, color='r', linestyle='dashed', linewidth=1, label=f'Average: {average_length:.2f}')
plt.axvline(percentile_90, color='g', linestyle='dashed', linewidth=1, label=f'90th Percentile: {percentile_90:.2f}')
plt.legend()
plt.show()

"""## Dataset and Dataloader

Window 的主要作用就是從長的 paragraph中切出一小段。
切出來的paragraph片段會和[CLS],[SEP],問題的token IDs 組合成模型的輸入 (input_ids)。
"""

class QA_Dataset(Dataset):
    def __init__(self, split, questions, tokenized_questions, tokenized_paragraphs):
        self.split = split
        self.questions = questions #原始問題列表
        self.tokenized_questions = tokenized_questions #tokenized了的問題
        self.tokenized_paragraphs = tokenized_paragraphs
        self.max_question_len = 40
        self.max_paragraph_len = 400

        ##### TODO: Change value of doc_stride #####
        self.doc_stride = 300 #保留些許上下文，這裡不同window的overlap留100減少運算

        # Input sequence length = [CLS] + question + [SEP] + paragraph + [SEP]
        self.max_seq_len = 1 + self.max_question_len + 1 + self.max_paragraph_len + 1

    def __len__(self):
        return len(self.questions)

    def __getitem__(self, idx):
        question = self.questions[idx]
        tokenized_question = self.tokenized_questions[idx]
        tokenized_paragraph = self.tokenized_paragraphs[question["paragraph_id"]]

        ##### TODO: Preprocessing #####
        # Hint: How to prevent model from learning something it should not learn

        if self.split == "train":
            # Convert answer's start/end positions in paragraph_text to start/end positions in tokenized_paragraph
            answer_start_token = tokenized_paragraph.char_to_token(question["answer_start"])
            answer_end_token = tokenized_paragraph.char_to_token(question["answer_end"])

            # A single window is obtained by slicing the portion of paragraph containing the answer
            #將含有答案的附近分成兩個window,1:....here is 2:answer...，合成包含完整answer的window
            mid = (answer_start_token + answer_end_token) // 2
            paragraph_start = max(0, min(mid - self.max_paragraph_len // 2, len(tokenized_paragraph) - self.max_paragraph_len))
            paragraph_end = paragraph_start + self.max_paragraph_len

            # Slice question/paragraph and add special tokens (101: CLS, 102: SEP) #組合question, 和存在答案的文章區間, 分隔by[SEP]
            input_ids_question = [101] + tokenized_question.ids[:self.max_question_len] + [102]
            input_ids_paragraph = tokenized_paragraph.ids[paragraph_start : paragraph_end] + [102]

            # Convert answer's start/end positions in tokenized_paragraph to start/end positions in the window
            answer_start_token += len(input_ids_question) - paragraph_start #調整答案位置(在組合後的input sequence的哪裡)
            answer_end_token += len(input_ids_question) - paragraph_start

            # Pad sequence and obtain inputs to model #給model的問題+段落長度必須相同於self.max_seq_len by填空白
            input_ids, token_type_ids, attention_mask = self.padding(input_ids_question, input_ids_paragraph)
            #input_ids回傳加上特殊符號和空白的問題+段落ids的tensor，token_type_ids回傳和input_ids相同長但問題、padding為0，paragraph為1的tensor，attention_mask回傳相同長度且除了paragraph為1其他為0的tensor
            return torch.tensor(input_ids), torch.tensor(token_type_ids), torch.tensor(attention_mask), answer_start_token, answer_end_token

        # Validation/Testing
        else:
            input_ids_list, token_type_ids_list, attention_mask_list = [], [], []

            # Paragraph is split into several windows, each with start positions separated by step "doc_stride"
            for i in range(0, len(tokenized_paragraph), self.doc_stride):

                # Slice question/paragraph and add special tokens (101: CLS, 102: SEP)
                input_ids_question = [101] + tokenized_question.ids[:self.max_question_len] + [102]
                input_ids_paragraph = tokenized_paragraph.ids[i : i + self.max_paragraph_len] + [102]

                # Pad sequence and obtain inputs to model
                input_ids, token_type_ids, attention_mask = self.padding(input_ids_question, input_ids_paragraph)

                input_ids_list.append(input_ids)
                token_type_ids_list.append(token_type_ids)
                attention_mask_list.append(attention_mask)

            return torch.tensor(input_ids_list), torch.tensor(token_type_ids_list), torch.tensor(attention_mask_list)

    def padding(self, input_ids_question, input_ids_paragraph):
        # Pad zeros if sequence length is shorter than max_seq_len
        padding_len = self.max_seq_len - len(input_ids_question) - len(input_ids_paragraph)
        # Indices of input sequence tokens in the vocabulary
        input_ids = input_ids_question + input_ids_paragraph + [0] * padding_len
        # Segment token indices to indicate first and second portions of the inputs. Indices are selected in [0, 1]
        token_type_ids = [0] * len(input_ids_question) + [1] * len(input_ids_paragraph) + [0] * padding_len
        # Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1]
        attention_mask = [1] * (len(input_ids_question) + len(input_ids_paragraph)) + [0] * padding_len

        return input_ids, token_type_ids, attention_mask

train_set = QA_Dataset("train", train_questions, train_questions_tokenized, train_paragraphs_tokenized)
dev_set = QA_Dataset("dev", dev_questions, dev_questions_tokenized, dev_paragraphs_tokenized)
test_set = QA_Dataset("test", test_questions, test_questions_tokenized, test_paragraphs_tokenized)

train_batch_size = 8

# Note: Do NOT change batch size of dev_loader / test_loader !
# Although batch size=1, it is actually a batch consisting of several windows from the same QA pair
train_loader = DataLoader(train_set, batch_size=train_batch_size, shuffle=True, pin_memory=True)
dev_loader = DataLoader(dev_set, batch_size=1, shuffle=False, pin_memory=True)
test_loader = DataLoader(test_set, batch_size=1, shuffle=False, pin_memory=True)

"""## Function for Evaluation"""

def evaluate(data, output):
    ##### TODO: Postprocessing #####
    # There is a bug and room for improvement in postprocessing
    # Hint: Open your prediction file to see what is wrong

    answer = ''
    max_prob = float('-inf')
    num_of_windows = data[0].shape[1]

    for k in range(num_of_windows):
        # Obtain answer by choosing the most probable start position / end position
        start_prob, start_index = torch.max(output.start_logits[k], dim=0)
        end_prob, end_index = torch.max(output.end_logits[k], dim=0)

        # Probability of answer is calculated as sum of start_prob and end_prob
        prob = start_prob + end_prob

        # Replace answer if calculated probability is larger than previous windows
        if prob > max_prob:
            max_prob = prob
            # Convert tokens to chars (e.g. [1920, 7032] --> "大 金")
            answer = tokenizer.decode(data[0][0][k][start_index : end_index + 1])

    # Remove spaces in answer (e.g. "大 金" --> "大金")
    return answer.replace(' ','')

"""## Training"""

num_epoch = 1
validation = True
logging_step = 100
learning_rate = 1e-4
optimizer = AdamW(model.parameters(), lr=learning_rate)

if fp16_training:
    model, optimizer, train_loader = accelerator.prepare(model, optimizer, train_loader)

#調learning rate
total_steps = len(train_loader) * num_epoch
print('total_steps', total_steps)
scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=0, num_training_steps=total_steps)


model.train()

print("Start Training ...")

for epoch in range(num_epoch):
  step = 1
  train_loss = train_acc = 0

  for data in tqdm(train_loader):
        # Load all data into GPU
    data = [i.to(device) for i in data]

        # Model inputs: input_ids, token_type_ids, attention_mask, start_positions, end_positions (Note: only "input_ids" is mandatory)
        # Model outputs: start_logits, end_logits, loss (return when start_positions/end_positions are provided)
    output = model(input_ids=data[0], token_type_ids=data[1], attention_mask=data[2], start_positions=data[3], end_positions=data[4])

        # Choose the most probable start position / end position
    start_index = torch.argmax(output.start_logits, dim=1)
    end_index = torch.argmax(output.end_logits, dim=1)

        # Prediction is correct only if both start_index and end_index are correct
    train_acc += ((start_index == data[3]) & (end_index == data[4])).float().mean()
    train_loss += output.loss

    if fp16_training:
        accelerator.backward(output.loss)
    else:
        output.loss.backward()

    optimizer.step()
    scheduler.step()
    optimizer.zero_grad()
    step += 1

        ##### TODO: Apply linear learning rate decay #####

        # Print training loss and accuracy over past logging step
    if step % logging_step == 0:
        print(f"Epoch {epoch + 1} | Step {step} | loss = {train_loss.item() / logging_step:.3f}, acc = {train_acc / logging_step:.3f}")
        train_loss = train_acc = 0

if validation:
    print("Evaluating Dev Set ...")
    model.eval()
    with torch.no_grad():
        dev_acc = 0
        total_evaluated = 0
        for i, data in enumerate(tqdm(dev_loader)):
            output = model(input_ids=data[0].squeeze(dim=0).to(device), token_type_ids=data[1].squeeze(dim=0).to(device),
                           attention_mask=data[2].squeeze(dim=0).to(device))
            dev_acc += evaluate(data, output) == dev_questions[i]["answer_text"]
            total_evaluated += 1
        print(f"Validation | Epoch {epoch + 1} | acc = {dev_acc / total_evaluated:.3f}")
    model.train()

# Save a model and its configuration file to the directory 「saved_model」
# i.e. there are two files under the direcory 「saved_model」: 「pytorch_model.bin」 and 「config.json」
# Saved model can be re-loaded using 「model = BertForQuestionAnswering.from_pretrained("saved_model")」
print("Saving Model ...")
model_save_dir = "saved_model"
model.save_pretrained(model_save_dir)

"""## Testing"""

print("Evaluating Test Set ...")

result = []

model.eval()
with torch.no_grad():
    for data in tqdm(test_loader):
        output = model(input_ids=data[0].squeeze(dim=0).to(device), token_type_ids=data[1].squeeze(dim=0).to(device),
                       attention_mask=data[2].squeeze(dim=0).to(device))
        result.append(evaluate(data, output))

result_file = "result.csv"
with open(result_file, 'w') as f:
	f.write("ID,Answer\n")
	for i, test_question in enumerate(test_questions):
      # Replace commas in answers with empty strings (since csv is separated by comma)
      # Answers in kaggle are processed in the same way
		  f.write(f"{test_question['id']},{result[i].replace(',','')}\n")

print(f"Completed! Result is in {result_file}")

"""![螢幕擷取畫面 2025-05-29 140330.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABMYAAADFCAYAAAC/1v5xAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEjwSURBVHhe7d17XJRV4sfxT1KQCZgKpSm2ibaJtj+11tuKaCAKSriipOJaUK7YhSzDykver6QZluJa2LpiLorJ4i3UVdK8bam7KXYBy1taIKzjmM0k+vtjZmAY7matON/368Ur5jznuT8Q5+s557nl6tWrVxEREREREREREXEydRwLREREREREREREnIGCMRERERERERERcUoKxkRERERERERExCkpGBMREREREREREaekYExERERERERERJySgjEREREREREREXFKCsZERERERERERMQpKRgTERERERERERGndMvVq1evOhZeL1/lHncsEhERERERERERuSH8osGYiIiIiIiIiIjIjUpDKUVERERERERExCkpGBMREREREREREaekYExERERERERERJySgjEREREREREREXFKCsZERERERERERMQpKRgTERERERERERGnpGBMRERERERERESckoIxERERERERERFxSgrGRERERERERETEKSkYExERERERERERp6RgTEREREREREREnJKCMRERERERERERcUoKxkRERERERERExCkpGBMREREREREREaekYExERERERERERJySgjEREREREREREXFKCsZERERERERERMQpKRgTERERERERERGnpGBMRERERERExFlcNmHIyyPPYHJcIvKrMhnyyMszYLrsuOTXdcvVq1evOhaKiIiIiIiIyE3ClMfuNbOYNz+TA4V2gZiLJy27DGLMpBfo4+tmv4bIL8KUm8m8KfP5+55cDEUl5W4N2tPnxRcYP7AL3r/yo6hgTEREREREROQmZTj4BtFDF3HAZAkfevZuSX3rsh9P7WHzrlOYgJaD32bl1GC8b3XYgMj1cDmP9DHhjM7IswayATzU7HbrwvMc3pjJEQPg3YNxSfMY0d7TYQO/HAVjIiIiIiIiIjchw7YXCRqRQZ53D8a9PY8RD5cTNlzM5e/j/sQrGXm4PfwK61c+SUuFY3I9Xc5laUQfZn5mCWCTJwXjU6ZXmIm8PYuIjVnEgcvePJa0mdmB5TyvvwAFYyIiIiIiIiI3m7OrifIfx+6GYSRvmU/P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)"""